## LibCo 学习

## 线程和协程区别

1. 线程是通过内核来调度的，而协程是用户态调度的；

2. 线程进程都是同步机制，而协程则是异步；

3.  CPU 密集型应用适用于单进程或者多进程，IO 密集型应用则适用于协程；

## 对称协程与非对称协程

对称协程指调用者与被调用者是对等关系，子协程之间来回切换；

非对称协程指 被调协程让出 cpu 以后，必须回到调用协程；在实际应用中，非对称协程更好用；

Libco 属于非对称协程；

## 独占栈与共享栈 ???

### libco 的协程是 stackful coroutine

每个协程都拥有一个独立的栈帧, 协程切换时会保存当前协程栈中的所有数据, 并加载新的栈帧对象

这样做的优点是: 协程调度可以在内存中的任意位置、任意时刻进行

但是缺点也很明显: 随着并发量的增加, 协程的数目越来越多, 当前内存中的协程栈(无论是 occupy 还是 suspend)越来越
多, 内存瓶颈开始显现, 且内存切换本身也是不小的开销(寄存器恢复、数据拷贝).

所以, stackful coroutine 一般有栈大小的限制(libco 是 128K)

### 共享栈

共享栈将协程划分为协程组, 同一个协程组中的协程共享同一块内存, 在协程切换的时候将当前内存中的数据保存到运行协程的 buffer中, 并将新
调度协程 buffer 中的数据拷贝到共享栈中. 如此既可以减少内存开销, 同时运行协程又没有了栈大小的限制. 

共享栈的缺点是: 协程调度产生的局部变量都在共享栈上, 一 旦新的协程运行后共享栈中的数据就会被覆盖, 先前协程的局部变量也就不再有效, 进而无法实现参数传递、嵌套调用等高级协程交互. 

此外, libco 的协程在共享栈上的切换还实现了 copy-on-write, 只有共享栈内存改变时才进行数据拷贝, 这是传
统的 stackful coroutine 所无法实现的

## 协程的原理

协程是通过汇编语言来保存和恢复函数执行上下文、使用 IO 事件或者定时器事件来控制 CPU 的执行策略来实现的；

