## 实验内容

1. 汇编程序 switch_to

2. 依次完成 PCB 切换、内核栈切换、LDT 切换等；

3. 修改 fork()，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子

4. 修改 PCB，即 task_struct 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。

5. 分析日志体会修改前后系统运行的差别

## 问题

```
movl tss,%ecx
addl $4096,%ebx
movl %ebx,ESP0(%ecx)
copy
```

1. 为什么要加 4096；
2. 什么没有设置 tss 中的 ss0。

```
*(--krnstack) = ebp;
*(--krnstack) = ecx;
*(--krnstack) = ebx;
*(--krnstack) = 0;
```

1. 子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？
2. 这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？
3. 这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？

为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？

## 首先

认识tss的工作原理

1. 重写 switch_to；

2. 将重写的 switch_to 和 schedule() 函数接在一起；

3. 修改现在的 fork()。