## 经典排序分类

冒泡 插入 选择  O(n^2)  基于比较

快排 归并   o(nlogn) 基于比较

桶 计数 基数  o(n) 不是基于比较



## 如何分析一个“排序算法”？

- 排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度  -- 对应 要排序的原始数据是什么样的。

2. 时间复杂度的系数、常数 、低阶

3. 比较次数和交换（或移动）次数

- 排序算法的内存消耗

- 排序算法的稳定性

## 冒泡排序

每次都是和相邻的比较，然后把最值送到最后

优化是可以提前终止， 如果无数据交换则停止

```cpp 
template<typename T> 
void bubble_sort(vector<T>& arr) {
    int len = arr.size();
	for (int i = 0; i < len - 1; i++) {
		bool flag = false;   // 提前退出冒泡循环的标志位	
		for (int j = 0; j < len - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				swap(arr[j], arr[j + 1]);
				flag = true;   // 表示有数据交换
			}
		}
		if(!flag) break;  // 没有数据交换，提前退出		
	}
}
```

### Q1 : 冒泡排序是原地排序算法吗？

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

### Q2 : 冒泡排序是稳定的排序算法吗？

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

## Q3 : 冒泡排序的时间复杂度是多少？

最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。

平均复杂度通过“有序度”和“逆序度”这两个概念来进行分析。

有序度是数组中具有有序关系的元素对的个数

比如 2，4，3，1 有序对 (2,4) (2,3) 两个

全有序的数组的有序度叫作满有序度。n*(n-1)/2

逆序度 = 满有序度 - 有序度

我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度

平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。

## 插入排序（Insertion Sort）

数据分为两个区间，已排序区间和未排序区间

初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

```cpp 
template<typename T> 
void insert_sort(vector<T>& arr) {
    if(arr.empty()) return;
    int n = arr.size();
    for(int i = 1; i < n; i++) {
        int value = arr[i];
        int j = i - 1;
        for(; j >= 0; j--) {
            if(a[j] > value) {
                a[j+1] = a[j];
            } else {
                break;
            }
        }
    }
    a[j+1] = value; // 插入数据
}
```

### Q1 : 插入排序是原地排序算法吗？

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，这是一个原地排序算法。


### Q2 : 插入排序是稳定的排序算法吗？

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

## Q3 : 时间复杂度是多少？

最好 O(n) 最差o(n^2)

插入一个数组的平均O(n),执行n次平均o(n^2)

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```cpp 
template<typename T> 
void select_sort(vector<T>& arr) {
    if(arr.empty()) return;
    int n = arr.size();
    for(int i = 0; i < n; i++) {
        int minIdx = i;
        for(int j = i + 1; j < n; j++) {
            if(arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        if(minIdx != i) swap(arr[i], arr[minIdx]);
    }
}
```

### Q1 : 插入排序是原地排序算法吗？

yes

### Q2 : 插入排序是稳定的排序算法吗？

不是,比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了

## Q3 : 时间复杂度是多少？

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)

## Q : 插入排序和冒泡排序的时间复杂度相同，都是 O(n^2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个

```cpp 
// 冒泡的数据交换展开
if(a[j] > a[j+1]) {
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
    flag = true;
}

// 插入排序的数据移动
if(a[j] > value) {
    a[j+1] = a[j]; // 数据移动
} else {
    break;
}
```

虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间

冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n^2)，比较高，适合小规模数据的排序

## 希尔排序 - 插入排序的一种更高效的改进版本

todo 

希尔排序是非稳定排序算法。



## 两种时间复杂度为 O(nlogn) 的排序算法，归并排序和快速排序

归并排序和快速排序都用到了分治思想，

## Q 如何用快排思想在O(n)内查找第K大元素？

## 归并排序（Merge Sort）

先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。



