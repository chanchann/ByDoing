## 堆 heap -- 一种特殊的树

堆排序是一种原地的、不稳定的，时间复杂度为 O(nlogn) 的排序算法

不稳定： 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

快速排序，平均情况下，它的时间复杂度为 O(nlogn)。

这两种排序算法的时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定，


## 堆的理解 

1. 堆是一个完全二叉树 (完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。)

2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。( = 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。)

大于等于 --> 大顶堆

小于等于 --> 小顶堆

## 如何存储一个堆

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![heap](https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg)

数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 2i​ 的节点。

## 堆上的操作

1. 插入

### 堆化 ： 顺着节点所在的路径，向上或者向下，对比，然后交换

- 从下往上 堆化

![heapify](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)

2. 删除堆顶元素

堆顶元素存储的就是堆中数据的最大值或者最小值。

- 从上往下 堆化

![heapify](https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg)

一个包含 n 个节点的完全二叉树，树的高度不会超过 log2​(n)。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)

插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

## 堆排序

O(nlogn)，原地排序

1. 建堆

将数组原地建成一个堆

第一种思路 : 在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。 (从前往后, 从下往上)

第二种思路 : 从后往前，从上往下

因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。找到比当前节点大的子节点，并且找到左右子节点的较大者，并交换

![heapify1](https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg)


![heapify2](https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg)

我们对下标从 2n​ 开始到 1 的数据进行堆化，对于完全二叉树来说，下标从 2n​+1 到 n 的节点都是叶子节点，我们不需要堆化。

## 建堆时间复杂度

堆排序的建堆过程的时间复杂度是 O(n) 

todo : “去推导”

https://www.zhihu.com/question/20729324

2. 排序

每次取出顶，和最后一个交换，顶是极值，所以就有序了。不断的建堆，然后取堆顶的元素

![sort](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)


## Q : 但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？

1. 堆排序数据访问的方式没有快速排序友好。

对于快速排序来说，数据是顺序访问的。

。。。 todo

## 堆的应用：TOPk 问题

## 1.应用一：优先级队列

在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。

如何实现一个优先级队列呢？方法有很多，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。

往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素

很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等

C++ 的 priority_queue

1. 合并有序小文件

假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。

整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。

这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。有没有更加高效方法呢？

这里就可以用到优先级队列，也可以说是堆

我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。

而删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)

2. 高性能定时器

定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行

这样每过 1 秒就扫描一遍任务列表的做法比较低效。

1）任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳

2）每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。

我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。

定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。

这样，定时器就可以设定在 T 秒之后，再来执行任务。在这之前定时器都不需要做任何事情。

当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。

定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了

## 应用二：利用堆求 Top K

Top K 的问题抽象成两类。

1. 一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。

我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。

遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。

比如数组 [4，5，3，7，1，8]，要取前3大元素 首先维护一个小顶堆，放入前三个数据，为 [3，4，5]； 接着遍历数组到元素7，比堆顶元素3大，将3移除，将7放入堆中，小顶堆变为 [4，5，7]； 接着遍历数组到元素1，比堆顶元素4小，不处理，接着遍历； 接着遍历数组到元素8，比堆顶元素4大，将4移除，将8放入堆中，小顶堆变为 [5，7，8]；

2. 另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。

一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。

如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)

实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。

